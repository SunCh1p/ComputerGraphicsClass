
// class Scene : public Component{
//     public:
//         Scene(Vector3 position = Vector3(0,0,0)): Component(position){}
//         void draw(Vector3 parentPosition = {0,0,0}, bool drawAxis, char mode) const override{
//             //get position in world
//             Vector3 globalPosition = parentPosition + m_position;
//             //draw all m_children relative to current position
//             for(auto& it: m_children){
//                 it->draw(globalPosition, drawAxis, mode);
//             }
//         }
//         void addChild(std::unique_ptr<Component> child) override{
//             //move unique ptr into container
//             m_children.push_back(std::move(child));
//         }
//     private:
//         std::vector<std::unique_ptr<Component>> m_children;
// };

// void init(){
//     /*select clearing background color*/
//     glClearColor(0.0, 0.0, 0.0, 0.0);
//     glMatrixMode(GL_PROJECTION);
//     glLoadIdentity();
//     gluPerspective(45.0, (double)WIN_W / WIN_H, 0.1, 100.0);
//     glMatrixMode(GL_MODELVIEW);
//     glLoadIdentity();
//     gluLookAt(
//         0.0, 2, 10.0,  // camera position
//         0.0, 0.0, 0.0,   // look at origin
//         0.0, 1.0, 0.0    // up vector
//     );
// }



//Cube(a leaf class)
class Cube : public Component{
    public:
        Cube(GLdouble size, Vector3 position = Vector3(0,0,0)): m_size(size), Component(position) {}
        void draw(Vector3 parentPosition, char mode) const override{
            //calculate global position
            Vector3 globalPosition = parentPosition+m_position;
            glPushMatrix();
                //set the position
                glTranslated(globalPosition.x, globalPosition.y, globalPosition.z);
                //set the color
                glColor3d(m_color.x, m_color.y, m_color.z);
                //draw based on mode
                if(mode == 'p'){
                    GLdouble point = m_size/2;
                    //draw vertex mode
                    glBegin(GL_POINTS);
                        //draw upper 4 corners
                        glVertex3d(point, point, point);
                        glVertex3d(point, point, -point);
                        glVertex3d(-point, point, point);
                        glVertex3d(-point, point, -point);
                        //draw lower 4 corners
                        glVertex3d(point, -point, point);
                        glVertex3d(point, -point, -point);
                        glVertex3d(-point, -point, point);
                        glVertex3d(-point, -point, -point);
                    glEnd();
                } else if(mode == 'w'){
                    //draw wireframe mode
                    glutWireCube(m_size);
                } else if(mode == 's'){
                    //draw solid mode
                    glutSolidCube(m_size);
                }
            glPopMatrix();
            //otherwise, do nothing
        }
    private:
        GLdouble m_size;
};

//Cube(a leaf class)
class Sphere : public Component{
    public:
        Sphere(GLdouble size, Vector3 position = Vector3(0,0,0)): m_radius(size), Component(position) {}
        void draw(Vector3 parentPosition, char mode) const override{
            //calculate global position
            Vector3 globalPosition = parentPosition+m_position;
            glPushMatrix();
                //set the position
                glTranslated(globalPosition.x, globalPosition.y, globalPosition.z);
                //set the color
                glColor3d(m_color.x, m_color.y, m_color.z);
                //draw based on mode
                if(mode == 'p'){
                    //TODO: make a vertex mode with spherical coordinates then convert to cartesian coordiantes
                    glBegin(GL_POINTS);

                    glEnd();
                } else if(mode == 'w'){
                    //draw wireframe mode
                    glutWireSphere(m_radius,10,10);
                } else if(mode == 's'){
                    //draw solid mode
                    glutSolidSphere(m_radius,10,10);
                }
            glPopMatrix();
            //otherwise, do nothing
        }
    private:
        GLdouble m_radius;
};